# Binary Heap Implementation

Данный репозиторий содержит реализацию бинарной кучи на JavaScript, которая основывается на реализации приоритетной очереди.

## Методы

### swim(queue, index)

Этот метод (или "подниматель") перемещает элементы внутреннего представления кучи (`queue`), пока не соблюдается свойства кучи. Метод принимает саму кучу и индекс элемента, который необходимо "поднять".

```javascript
function swim(queue, index) {
    while (index > 1 && less(queue, index/2, index)) {
        exchange(queue, index, index/2);
        index = index/2;
    }
}
```

### sink(queue, index)

Этот метод (или "погружатель") удаляет элемент из кучи и затем выполняет необходимые перемещения для сохранения свойства кучи. Метод принимает кучу и индекс элемента, который нужно "погрузить".

```javascript
function sink(queue, index) {
    while (2*index <= N) {
        let j = 2*index;
        if (j < N && less(queue, j, j+1)) j++;
        if (!less(queue, index, j)) break;
        exchange(queue, index, j);
        index = j;
    }
}
```

### less(queue, index1, index2)

Метод для сравнения двух элементов кучи. Метод принимает саму кучи и индексы элементов для сравнения. Возвращает `true`, если первый элемент меньше второго.

```javascript
function less(queue, index1, index2) {
    return queue[index1] < queue[index2];
}
```

### exchange(queue, index1, index2)

Метод для обмена двумя элементами на основе их индексов в куче. Метод принимает кучу и индексы элементов для обмена.

```javascript
function exchange(queue, index1, index2) {
    let temp = queue[index1];
    queue[index1] = queue[index2];
    queue[index2] = temp;
}
```
Примечание: В приведенных выше примерах использования методов N - это размер бинарной кучи.

## Пример использования

```javascript
const pq = new PriorityQueue();
pq.insert(10);
pq.insert(20);
pq.insert(30);
pq.insert(5);


console.assert(pq.delMax() === 30, "Куча должна вернуть 30!");
console.assert(pq.delMax() === 20, "Куча должна вернуть 20!");

```
В этом примере мы создаем новую очередь, добавляем в нее несколько элементов и затем удаляем самые большие элементы.

Напоминаем, что в бинарной куче, реализованной в виде массива, индексы начинаются с 1, а не с 0. Поэтому первый элемент в массиве оставлен неизменным. Максимальный элемент всегда находится в queue[1]. Это упрощает вычисление индексов для родительского элемента и потомков.