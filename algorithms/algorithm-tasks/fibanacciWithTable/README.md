[fib tabulation time code](https://www.youtube.com/watch?v=oBt53YbR9Kk&t=11453s)

[Назад к содержанию](../README.md)

# Документация функции `fibanacchiWithTable`

## Описание

Функция `fibanacchiWithTable` реализует эффективный алгоритм для вычисления числа Фибоначчи с использованием табличного метода (bottom-up approach), который избегает экспоненциального времени выполнения, свойственного рекурсивной реализации.

Последовательность Фибоначчи — это ряд чисел, в котором каждое следующее число является суммой двух предыдущих. Первые два числа последовательности обычно равны 1 (или 0 и 1), а каждое последующее число равно сумме двух предшествующих чисел.

## Принцип работы

Функция принимает один аргумент:

- `num`: индекс (позиция) числа в последовательности Фибоначчи, которое нужно вычислить.

Алгоритм работы функции `fibanacchiWithTable` состоит из следующих шагов:

1. Инициализация массива `table` фиксированной длины, равной `num + 1`, заполненного нулями. Этот массив будет использоваться как таблица для хранения промежуточных результатов вычисления чисел Фибоначчи.

```javascript
const table = Array(num + 1).fill(0);
```

2. Установка значения второго элемента массива `table` равным 1, так как первое число Фибоначчи (для индекса 1) равно 1.

```javascript
table[1] = 1;
```

3. Использование цикла `for` для итерации от нулевого элемента до `num`. На каждом шаге цикла:

    - К текущему значению в таблице для позиции `i + 1` прибавляется значение текущей позиции `i`. Это позволяет вычислить следующее число Фибоначчи и сохранить его в таблице.

   ```javascript
   table[i + 1] += table[i];
   ```

    - К текущему значению в таблице для позиции `i + 2` прибавляется значение текущей позиции `i`. Это действие вычисляет число Фибоначчи на две позиции вперед и сохраняет его в таблице. Эта операция необходима, чтобы при следующем проходе цикла у нас уже было сохранено значение для `i + 1`.

   ```javascript
   table[i + 2] += table[i];
   ```

4. После завершения цикла возвращается элемент массива с индексом `num`, который содержит искомое число Фибоначчи.

```javascript
return table[num];
```

## Особенности реализации

- Метод итеративного вычисления позволяет избежать проблем, связанных с рекурсией, таких как переполнение стека вызовов и повторные вычисления уже известных значений.

- Функция использует принцип динамического программирования с табуляцией, т.е. сохраняет результаты промежуточных вычислений, чтобы они могли быть использованы повторно.

- Временная сложность алгоритма составляет O(n), что делает его значительно более эффективным, чем наивный рекурсивный подход с временной сложностью O(2^n).

- Пространственная сложность тоже O(n) из-за необходимости сохранения таблицы значений.

- Использование таблицы значений позволяет функции поддерживать вычисление больших значений чисел Фибоначчи, которые могли бы быть недоступны из-за ограничений рекурсии или неэффективности при больших значениях `num`.

## Пример использования

Допустим, вам нужно вычислить 10-е число Фибоначчи. Используйте функцию следующим образом:

```javascript
import { fibanacchiWithTable } from 'путь-к-файлу'; // Замените 'путь-к-файлу' реальным путём

const result = fibanacchiWithTable(10);
console.log(result); // Выведет 55, так как 10-е число Фибоначчи — 55
```

## Примечания

Важно отметить, что хотя алгоритм и позволяет вычислять большие числа быстрее и без риска переполнения стека вызовов, которые присущи рекурсивной реализации, объем используемой памяти остаётся значительным. Для случаев, когда память ограничена, может потребоваться другой подход, который не сохраняет все промежуточные значения последовательности Фибоначчи.

Ещё одним значимым фактором является тип числовых значений, с которыми может работать JavaScript. В современных JavaScript-движках числа представлены с использованием 64-битных значений с плавающей запятой, что может влиять на точность при работе с очень большими числами.

## Заключение

Функция `fibanacchiWithTable` представляет собой пример эффективного алгоритма для работы с классической задачей вычисления чисел Фибоначчи. Через применение динамического программирования и табуляции, данная функция демонстрирует, как можно избежать недостатков наивной рекурсии и значительно ускорить вычисления за счёт использования дополнительной памяти для хранения промежуточных результатов.

Алгоритм хорошо подходит для случаев, когда нужно многократно вычислять числа Фибоначчи для различных значений, поскольку он позволяет избегать повторного вычисления уже известных чисел, сохраняя промежуточные результаты в таблице.

Реализуя этот метод, разработчики могут обеспечить повышенную производительность и оптимизацию памяти для приложений, требующих расчётов в областях таких как математика, финансы, машинное обучение и других, где последовательности чисел Фибоначчи находят своё применение.

Вместе с тем, необходимо помнить о том, что при работе с очень длинными последовательностями возможны ограничения памяти, и в таких случаях порой целесообразнее использовать более продвинутые техники, такие как алгоритмы, которые используют матричное представление чисел Фибоначчи или формулу Бине для нахождения приблизительных значений чисел Фибоначчи.

В любом случае, выбор метода остается за разработчиком и зависит от конкретных задач и условий, в которых функция будет использоваться. Функция `fibanacchiWithTable` является мощным инструментом в наборе инструментов программиста, особенно когда речь идёт о быстром и эффективном решении проблем, связанных с числами Фибоначчи, благодаря своей способности оптимизировать использование ресурсов и обеспечивать результаты с высокой производительностью.

Тем не менее, следует также учитывать возможность целочисленного переполнения. В JavaScript (на момент написания, до марта 2023 года) максимально безопасное целое число, с которым можно работать, это `Number.MAX_SAFE_INTEGER`, равное `9007199254740991`. При расчётах больших чисел Фибоначчи этот предел может быть быстро достигнут, что приведёт к неточностям в вычислениях. В таких случаях потребуется использование специальных библиотек для работы с большими числами (big integer libraries), способных обрабатывать числа произвольной длины.

И, наконец, необходимо отметить, что, несмотря на универсальность и производительность алгоритма с табуляцией, он может быть не всегда подходящим для использования в условиях ограниченного объёма памяти. В таких случаях может быть более целесообразным использование метода, который вычисляет числа Фибоначчи "на лету", без сохранения всех предыдущих значений последовательности, например, храня только последние два вычисленных числа.

В результате, функция `fibanacchiWithTable` является примером динамического программирования с подходом "с низу вверх", который может быть использован не только для вычисления чисел Фибоначчи, но и для решения широкого спектра других задач, где принцип разбиения большой задачи на подзадачи и сохранение результатов промежуточных вычислений для их использования в будущем может быть важен.
Используя этот подход, разработчики могут рационализировать ресурсы и время выполнения программ, что делает эту технику особенно ценной для задач оптимизации, компьютерной графики, биоинформатики, а также многих других областей, где встают вопросы об обработке больших массивов данных или выполнении сложных вычислений.
Заключительным моментом при работе с алгоритмом fibanacchiWithTable является понимание, что данная функция хорошо поддается тестированию, в том числе автоматизированному. Модульность функции — её способность работать изолированно от остальной части программы — облегчает создание тестовых сценариев, которые могут проверять её работу на различных наборах входных данных, обеспечивая надёжность и корректность работы в рамках более крупного приложения или системы.