[allConstruct memoization time code](https://www.youtube.com/watch?v=oBt53YbR9Kk&t=10050s)

[Назад к содержанию](../README.md)

# allConstruct
```javascript
/**
 * Функция allConstruct возвращает все возможные комбинации, которыми можно
 * построить target строку, используя слова из массива wordBank. Реализация
 * использует мемоизацию для улучшения производительности.
 * 
 * @param {string} target - Целевая строка для построения.
 * @param {string[]} wordBank - Массив слов, которые можно использовать для построения.
 * @param {Object} memo - Объект для мемоизации промежуточных результатов.
 * @returns {Array<Array<string>>} - Массив, содержащий все уникальные комбинации слов, которые строят target.
 * 
 * Комплексность времени: O(n^m) - где n - количество слов в wordBank, m - длина target строки.
 * Комплексность пространства: O(m) - максимальная глубина рекурсивного дерева вызовов.
 */

export function allConstruct(target, wordBank, memo = {}) {
    // Проверка мемоизированных результатов O(1) - константная
    if (target in memo) {
        return memo[target]; // O(1) - влияние на общую сложность константное
    }

    // Базовый случай: пустая target строка O(1)
    if (target === '') {
        return [[]]; // O(1) - константное влияние на сложности
    }

    const result = []; // Инициализация массива для хранения результатов O(1)

    // Цикл по каждому слову в wordBank O(n)
    for (const word of wordBank) {
        // Проверяется, начинается ли target с текущего слова O(m)
        if (target.startsWith(word)) {
            // Вычисляем суффикс, убирая найденное слово из начала target O(m)
            const suffix = target.slice(word.length);
            
            // Рекурсивно строим все конструкции для суффикса O(n^m)
            // (рассмотрены все части target за все итерации)
            const suffixWays = allConstruct(suffix, wordBank, memo);
            
            // Создаем конструкции для текущего target, добавив word перед каждым путем из suffixWays O(l), где l - длина suffixWays
            const targetWays = suffixWays.map(way => [word, ...way]);
            
            // Добавляем полученные пути в общий результат O(l), где l - общее количество путей
            result.push(...targetWays);
        }
    }

    // Сохраняем вычисленный результат в memo для текущего target O(m)
    memo[target] = result;
    
    // Возвращаем результат O(1)
    return result;
}
```

Каждый вызов функции `allConstruct` может вызвать множество других вызовов самой себя в зависимости от количества слов в `wordBank`, которые могут быть префиксами `target`. Следовательно, если не учитывать оптимизацию через мемоизацию, то каждый неразрешенный вызов может порождать до `n` дальнейших вызовов где `n` - это количество слов в `wordBank`. Таким образом, пути возможных вызовов функции образуют дерево, где каждый узел может иметь до `n` дочерних узлов. В худшем случае функция на каждом уровне будет вызывать

## Принцип работы

Функция `allConstruct` использует рекурсивный подход с мемоизацией для уменьшения количества повторных вычислений и оптимизации работы. Она работает следующим образом:

1. Если цель (`target`) уже есть в мемо (`memo`), то возвращается сохраненное значение, чтобы избежать повторных вычислений.
2. Если цель пустая строка (`''`), то возвращается массив, содержащий пустой массив (пустое сочетание слов).
3. Для каждого слова (`word`) в `wordBank`:
    - Если цель начинается с текущего слова (`word`), то:
        - Вычисляется оставшаяся часть цели после удаления префикса (`suffix = target.slice(word.length)`).
        - Рекурсивно вызывается функция `allConstruct` для оставшейся части цели (`suffix`).
        - Для каждого возможного сочетания оставшейся части (`suffixWays`), создается новое сочетание, добавляя текущее слово в начало.
        - Новые сочетания добавляются в результирующий массив (`result`).
4. Результаты сохраняются в мемо для текущей цели.
5. Возвращается результирующий массив (`result`), содержащий все возможные комбинации слов, которые могут быть объединены в целевое слово.

## Особенности реализации

- Функция `allConstruct` использует рекурсию для разбиения задачи на более простые подзадачи.
- Мемоизация (использование объекта `memo`) позволяет сохранять результаты ранее вычисленных целей и избегать повторных вычислений для этих целей.
- Метод `startsWith` используется для проверки, начинается ли цель с заданного слова. Это позволяет определить, возможно ли объединить слово в целевое слово.
- Массивы `suffixWays` и `targetWays` обновляются путем добавления текущего слова (`word`) или комбинации текущего слова и оставшейся части цели.

## Анализ концепций

- **Рекурсия**: Функция `allConstruct` использует рекурсию для разбиения задачи на более простые подзадачи и последовательного решения каждой из них.
- **Мемоизация**: Использование объекта `memo` позволяет сохранять результаты ранее вычисленных целей и избегать повторных вычислений для этих целей. Это значительно улучшает производительность функции.
- **Динамическое программирование**: Принципы динамического программирования применяются в функции `allConstruct`. Оптимальное решение задачи строится из оптимальных решений ее подзадач.

