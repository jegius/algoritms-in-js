[canSum memoization](https://www.youtube.com/watch?v=oBt53YbR9Kk&t=4196s)

[Назад к содержанию](../README.md)

# canSum

Функция `canSum` предоставляет решение задачи проверки возможности получения целевой суммы (`targetSum`) путем сложения чисел из заданного набора (`numbers`).

## Принцип работы

Функция `canSum` использует рекурсивный подход с мемоизацией для уменьшения количества повторных вычислений и оптимизации работы. Она работает следующим образом:

1. Если целевая сумма (`targetSum`) уже есть в мемо (`memo`), то возвращается сохраненное значение, чтобы избежать повторных вычислений.
2. Если целевая сумма равна 0, значит, целевая сумма может быть получена путем сложения чисел из набора, поэтому возвращается значение `true`.
3. Если целевая сумма меньше 0, значит, целевая сумма не может быть получена путем сложения чисел из набора, поэтому возвращается значение `false`.
4. Для каждого числа (`num`) в наборе `numbers`:
    - Вычисляется остаток от разности между целевой суммой и текущим числом (`remainder = targetSum - num`).
    - Рекурсивно вызывается функция `canSum` для остатка (`remainder`) и того же набора чисел (`numbers`).
    - Если для остатка получено значение `true`, значит, целевая сумма может быть получена путем сложения чисел из набора. В этом случае, значение `true` сохраняется в мемо для текущей целевой суммы и возвращается `true`.
5. Если ни одно число из набора не приводит к достижению целевой суммы, то возвращается значение `false` и сохраняется в мемо для текущей целевой суммы.

## Особенности реализации

- Функция `canSum` использует рекурсию для поиска возможности получения целевой суммы путем сложения чисел.
- Мемоизация (использование объекта `memo`) позволяет сохранять результаты ранее вычисленных целевых сумм и избегать повторных вычислений для этих сумм.
- Функция возвращает значение `true`, если целевая сумма может быть получена, и значение `false`, если не может.
- Остаток (`remainder`) вычисляется путем вычитания текущего числа (`num`) из целевой суммы.
- Полученные результаты сохраняются в мемо для каждой проверяемой целевой суммы.

## Анализ концепций

- **Рекурсия**: Функция `canSum` использует рекурсию для разбиения задачи на более простые подзадачи и последовательного решения каждой из них.
- **Мемоизация**: Использование объекта `memo` позволяет сохранять результаты ранее вычисленных целевых сумм и избегать повторных вычислений для этих сумм. Это значительно улучшает производительность функции.
- **Динамическое программирование**: Принципы динамического программирования применяются в функции `canSum`. Оптимальное решение задачи строится из оптимальных решений ее подзадач.

## Разбор построчно с пояснениями

```javascript
export function canSum(targetSum, numbers, memo = {}) {
    // Проверка, есть ли целевая сумма в мемо
    if (targetSum in memo) {
        return memo[targetSum];
    }

    // Проверка, является ли целевая сумма равной 0
    if (targetSum === 0) {
        return true;
    }

    // Проверка, является ли целевая сумма отрицательным числом
    if (targetSum < 0) {
        return false;
    }

    // Проход по числам массива
    for (const num of numbers) {
        // Вычисление остатка от разности целевой суммы и числа
        const remainder = targetSum - num;
        // Рекурсивный вызов функции canSum для остатка
        if (canSum(remainder, numbers, memo) === true) {
            // Если для остатка вернулось true, сохраняем true в мемо и возвращаем true
            memo[targetSum] = true;
            return true;
        }
    }

    // Если ни одно число не приводит к достижению целевой суммы,
    // сохраняем false в мемо и возвращаем false
    memo[targetSum] = false;
    return false;
}
```

## Пояснения по коду

- Функция `canSum` рекурсивно проверяет, может ли целевая сумма быть получена путем сложения чисел из массива `numbers`.
- Входные параметры:
   - `targetSum`: Целевая сумма, которую нужно получить.
   - `numbers`: Массив чисел, которые могут быть использованы для получения целевой суммы.
   - `memo`: Объект, используемый для мемоизации результата (по умолчанию пустой объект `{}`).

- Проверка наличия целевой суммы в объекте `memo`. Если результат уже сохранен, он возвращается, чтобы избежать повторных вычислений и улучшить производительность.
- Проверка, является ли целевая сумма равной 0. Если равна, то целевую сумму можно получить путем сложения чисел из массива, поэтому возвращается `true`.
- Проверка, является ли целевая сумма отрицательным числом. Если число отрицательное, то целевую сумму невозможно получить путем сложения чисел из массива, поэтому возвращается `false`.
- Проход по каждому числу из массива `numbers`:
   - Вычисление остатка (`remainder`) от разности целевой суммы и текущего числа.
   - Рекурсивный вызов функции `canSum` для остатка и того же массива `numbers` и объекта `memo`.
   - Если для остатка получено значение `true`, то целевая сумма может быть получена, поэтому:
      - Значение `true` сохраняется в `memo` для текущей целевой суммы.
      - Возвращается `true`.
- Если ни одно число из массива не приводит к достижению целевой суммы, значит, целевую сумму невозможно получить, поэтому:
   - Значение `false` сохраняется в `memo` для текущей целевой суммы.
   - Возвращается `false`.

## Примеры использования

```javascript
console.log(canSum(7, [2, 3])); // true
console.log(canSum(7, [5, 3, 4, 7])); // true
console.log(canSum(7, [2, 4])); // false
console.log(canSum(8, [2, 3, 5])); // true
console.log(canSum(300, [7, 14])); // false
```