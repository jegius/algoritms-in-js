[allConstruct tabulation time code](https://www.youtube.com/watch?v=oBt53YbR9Kk&t=17423s)

[Назад к содержанию](../README.md)

# allConstructWithTable

## Описание

Функция `allConstructWithTable` предоставляет решение задачи поиска всех возможных комбинаций с использованием заданных частей (`parts`) для формирования цели (`target`). Функция использует подход с использованием таблицы для хранения всех комбинаций.

## Принцип работы

1. Создание и инициализация таблицы (`table`) размером `(target.length + 1)`.
    - Длина таблицы равна длине цели `target`, увеличенной на 1, чтобы учесть случай, когда все части `parts` использованы полностью и достигнута конец цели.

2. Инициализация первого элемента таблицы (`table[0]`) пустым массивом `[]`.
    - Это означает, что нулевая длина цели может быть достигнута без использования каких-либо частей, поэтому комбинациями являются пустые массивы.

3. Перебор индексов таблицы от 0 до `target.length` включительно.
    - Это соответствует длине цели и позволяет рассматривать все префиксы цели от пустого префикса до полной цели.

4. Для каждой части `part` из массива `parts`:
    - Проверка, совпадает ли часть `part` с подстрокой цели `target` начиная с текущего индекса `i`.
    - Если совпадение обнаружено:
        - Создание новых комбинаций путем объединения каждой комбинации из таблицы для предыдущего индекса `i` с текущей частью `part`.
        - Добавление новых комбинаций в таблицу для индекса `i + part.length`.

5. Возврат всех комбинаций, находящихся в последнем элементе таблицы (`table[target.length]`).

## Особенности реализации

- Функция `allConstructWithTable` использует подход с использованием таблицы для хранения всех комбинаций.
- Каждый элемент таблицы (`table[i]`) является массивом комбинаций, где индекс `i` представляет текущую длину префикса цели.
- Изначально, первый элемент таблицы (`table[0]`) инициализируется пустым массивом, так как пустой префикс цели может быть достигнут без использования каких-либо частей.
- Для каждого индекса `i` таблицы и каждой части `part` из массива `parts`, происходит проверка на совпадение части `part` с подстрокой цели начиная с текущего индекса `i`.
- Если совпадение найдено, создаются новые комбинации путем объединения текущей комбинации из таблицы для индекса `i` с текущей частью `part`, и эти новые комбинации добавляются в таблицу для индекса `i + part.length`.
- На выходе возвращаются все комбинации, находящиеся в последнем элементе таблицы (`table[target.length]`).

## Примеры использования

```javascript
console.log(allConstructWithTable('abcdef', ['ab', 'abc', 'cd', 'def', 'abcd']));
// [
//     ['ab', 'cd', 'ef'],
//     ['abc', 'def'],
//     ['abcd', 'ef']
// ]

console.log(allConstructWithTable('purple', ['purp', 'p', 'ur', 'le', 'purpl']));
// [
//     ['purp', 'le'],
//     ['p', 'ur', 'p', 'le']
// ]

console.log(allConstructWithTable('skateboard', ['bo', 'rd', 'ate', 't', 'ska', 'sk', 'boar']));
// []

console.log(allConstructWithTable('eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef', ['e', 'ee', 'eee', 'eeee', 'eeeee']));
// []

```

## Временная сложность

Временная сложность функции `allConstructWithTable` зависит от размера входных данных, а именно от длины цели `target` и количества частей `parts`. В худшем случае, когда каждая часть `part` может быть использована для формирования цели `target`, функция может иметь экспоненциальную временную сложность O(n^m), где n - количество частей `parts`, m - длина цели `target`. Однако, использование таблицы позволяет избежать повторных вычислений комбинаций, что значительно улучшает производительность в большинстве случаев.
