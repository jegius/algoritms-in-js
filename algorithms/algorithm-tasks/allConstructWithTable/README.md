[allConstruct tabulation time code](https://www.youtube.com/watch?v=oBt53YbR9Kk&t=17423s)

[Назад к содержанию](../README.md)

# allConstructWithTable
```javascript
/**
 * Функция allConstructWithTable вычисляет все способы, которыми можно сконструировать
 * целевую строку `target` из кусочков `parts` используя динамическое программирование с таблицей.
 *
 * @param {string} target - Целевая строка для построения.
 * @param {string[]} parts - Массив строк, которые можно использовать для построения target.
 * @returns {string[][]} - Двумерный массив, содержащий все уникальные способы построения target.
 *
 * Алгоритмическая сложность: O(m^2 * n) - где m - длина target строки, n - количество элементов в parts.
 * Занимаемое пространство: O(m^2) - максимальный размер таблицы.
 */

export function allConstructWithTable(target, parts) {
   // Создаем таблицу для динамического программирования с длиной target.length + 1 O(m)
   const table = Array(target.length + 1)
           // Заполняем таблицу пустыми массивами O(m)
           .fill()
           .map(() => []);

   // Базовый случай: для пустой строки только один способ её построить - не использовать ни одной части O(1)
   table[0] = [[]];

   // Перебираем строки стартовой длины от 0 до target.length O(m)
   for (let i = 0; i <= target.length; i++) {
      // Перебираем все части O(n)
      for (const part of parts) {
         // Проверяем, совпадает ли часть с подстрокой target начиная с индекса i O(m)
         if (target.slice(i, i + part.length) === part) {
            // Создаем новые комбинации путем добавления текущей части к каждому существующему пути в table[i] O(m^2)
            // так как потенциально может быть до m путей, и каждой добавление части занимает до m операций
            const newCombinations = table[i].map(subarray => [...subarray, part]);
            // Добавляем новые комбинации в таблицу, увеличивая индекс на длину текущей части O(m^2)
            // в худшем случае каждый путь в table[i] может вести к добавлению нового пути длиной до m 
            table[i + part.length].push(...newCombinations);
         }
      }
   }

   // Возвращаем результат из последней ячейки таблицы, которая содержит искомые комбинации O(1)
   return table[target.length];
}
```
## Описание

Функция `allConstructWithTable` предоставляет решение задачи поиска всех возможных комбинаций с использованием заданных частей (`parts`) для формирования цели (`target`). Функция использует подход с использованием таблицы для хранения всех комбинаций.

## Принцип работы

1. Создание и инициализация таблицы (`table`) размером `(target.length + 1)`.
    - Длина таблицы равна длине цели `target`, увеличенной на 1, чтобы учесть случай, когда все части `parts` использованы полностью и достигнута конец цели.

2. Инициализация первого элемента таблицы (`table[0]`) пустым массивом `[]`.
    - Это означает, что нулевая длина цели может быть достигнута без использования каких-либо частей, поэтому комбинациями являются пустые массивы.

3. Перебор индексов таблицы от 0 до `target.length` включительно.
    - Это соответствует длине цели и позволяет рассматривать все префиксы цели от пустого префикса до полной цели.

4. Для каждой части `part` из массива `parts`:
    - Проверка, совпадает ли часть `part` с подстрокой цели `target` начиная с текущего индекса `i`.
    - Если совпадение обнаружено:
        - Создание новых комбинаций путем объединения каждой комбинации из таблицы для предыдущего индекса `i` с текущей частью `part`.
        - Добавление новых комбинаций в таблицу для индекса `i + part.length`.

5. Возврат всех комбинаций, находящихся в последнем элементе таблицы (`table[target.length]`).

## Особенности реализации

- Функция `allConstructWithTable` использует подход с использованием таблицы для хранения всех комбинаций.
- Каждый элемент таблицы (`table[i]`) является массивом комбинаций, где индекс `i` представляет текущую длину префикса цели.
- Изначально, первый элемент таблицы (`table[0]`) инициализируется пустым массивом, так как пустой префикс цели может быть достигнут без использования каких-либо частей.
- Для каждого индекса `i` таблицы и каждой части `part` из массива `parts`, происходит проверка на совпадение части `part` с подстрокой цели начиная с текущего индекса `i`.
- Если совпадение найдено, создаются новые комбинации путем объединения текущей комбинации из таблицы для индекса `i` с текущей частью `part`, и эти новые комбинации добавляются в таблицу для индекса `i + part.length`.
- На выходе возвращаются все комбинации, находящиеся в последнем элементе таблицы (`table[target.length]`).

## Примеры использования

```javascript
console.log(allConstructWithTable('abcdef', ['ab', 'abc', 'cd', 'def', 'abcd']));
// [
//     ['ab', 'cd', 'ef'],
//     ['abc', 'def'],
//     ['abcd', 'ef']
// ]

console.log(allConstructWithTable('purple', ['purp', 'p', 'ur', 'le', 'purpl']));
// [
//     ['purp', 'le'],
//     ['p', 'ur', 'p', 'le']
// ]

console.log(allConstructWithTable('skateboard', ['bo', 'rd', 'ate', 't', 'ska', 'sk', 'boar']));
// []

console.log(allConstructWithTable('eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef', ['e', 'ee', 'eee', 'eeee', 'eeeee']));
// []

```

## Временная сложность

Временная сложность функции `allConstructWithTable` зависит от размера входных данных, а именно от длины цели `target` и количества частей `parts`. В худшем случае, когда каждая часть `part` может быть использована для формирования цели `target`, функция может иметь экспоненциальную временную сложность O(n^m), где n - количество частей `parts`, m - длина цели `target`. Однако, использование таблицы позволяет избежать повторных вычислений комбинаций, что значительно улучшает производительность в большинстве случаев.
