[gridTraveler memoization](https://www.youtube.com/watch?v=oBt53YbR9Kk&t=2319s)

[Назад к содержанию](../README.md)

# Описание функции `gridTraveler`

Функция `gridTraveler` представляет собой рекурсивную реализацию задачи о количестве уникальных путей перемещения в сетке с размерами `m` на `n`. Эта задача заключается в том, чтобы подсчитать количество способов переместиться из верхнего левого угла сетки в нижний правый, двигаясь только вниз или вправо.

## Принцип работы

Для понимания работы кода рассмотрим приведенный ниже алгоритм.

```javascript
export function gridTraveler(m, n) {
    if (m === 1 && n === 1) {
        return 1;
    }
    if (m === 0 || n === 0) {
        return 0;
    }

    return gridTraveler(m - 1, n) + gridTraveler(m, n - 1);
}
```

Рассмотрим подробно каждый шаг алгоритма:

- **Базовый случай**: При `m === 1 && n === 1` мы находимся в нижнем правом углу сетки, что означает, что мы нашли один уникальный путь, поэтому возвращается `1`.

- **Единица измерения пути**: Когда одна из сторон сетки равна `0` (то есть `m === 0 || n === 0`), переместиться вправо или вниз невозможно (так как это выйдет за пределы сетки), и потому количество уникальных путей в этом случае равно `0`.

- **Рекурсивные вызовы**: Возвращаемое значение функции состоит из суммы двух результатов рекурсивных вызовов: `gridTraveler(m - 1, n)` и `gridTraveler(m, n - 1)`. Это соответствует кол ичеству уникальных путей, если мы переместимся вниз (уменьшим `m` на `1`, при этом `n` останется неизменным) и количеству уникальных путей, если мы переместимся вправо (уменьшим `n` на `1`, при этом `m` останется неизменным). Каждый рекурсивный вызов продолжает делить проблему на подпроблемы до тех пор, пока не будет достигнут базовый случай.

## Особенности реализации

Текущая реализация `gridTraveler` использует базовую рекурсию без сохранения результатов подзадач. Это может привести к повторным вычислениям одной и той же подзадачи, особенно в случаях с большими значениями `m` и `n`, что делает процесс вычисления неоптимальным с точки зрения времени.

Пример использования:
```javascript
console.log(gridTraveler(2, 3)); // Выведет 3, так как есть три уникальных пути из (1,1) в (2,3)
```

## Практический анализ

### Пространственная сложность

Пространственная сложность данной реализации определяется глубиной рекурсивного стека, который в худшем случае может быть O(m+n).

### Временная сложность

Временная сложность — экспоненциальная, точнее O(2^(m+n)), так как каждый вызов `gridTraveler` рекурсивно вызывает себя дважды, за исключением базовых случаев.

### Концепции

Данный код использует несколько важных концепций и подходов:

- **Рекурсия**: Код использует рекурсивные вызовы Функция `gridTraveler` демонстрирует классический пример применения рекурсии для решения комбинаторной задачи, сочетающий в себе простоту и выразительность, однако из-за экспоненциального роста числа рекурсивных вызовов может стать крайне неэффективным при увеличении размеров сетки. Это приводит к необходимости использования оптимизаций, таких как динамическое программирование, мемоизация или табуляция, чтобы сократить количество повторных вычислений.

Для большей эффективности и улучшения временной сложности рекомендуется модифицировать функцию, добавив кэширование уже вычисленных значений, что значительно ускорит её работу:

```javascript
const memo = {};
export function gridTraveler(m, n) {
    const key = m + ',' + n;
    // Проверка наличия значения в кэше
    if (key in memo) return memo[key];
    if (m === 1 && n === 1) return 1;
    if (m === 0 || n === 0) return 0;

    // Кэширование результата перед возвратом
    memo[key] = gridTraveler(m - 1, n) + gridTraveler(m, n - 1);
    return memo[key];
}
```

Таким образом, с помощью простой оптимизации мы можем улучшить временную сложность этого алгоритма до O(m*n) и сделать его пригодным для решения задач на больших сетках, сохраняя результаты вычислений по мере продвижения.