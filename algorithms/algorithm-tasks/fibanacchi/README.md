[fib memoization time code](https://www.youtube.com/watch?v=oBt53YbR9Kk&t=210s)

[Назад к содержанию](../README.md)

# fibanacci

## Обзор

Функция `fibanaсchi` предназначена для вычисления n-го числа Фибоначчи. Последовательность Фибоначчи — это ряд чисел, в котором каждое следующее число равно сумме двух предыдущих. Первые два числа в последовательности Фибоначчи — это, обычно, 1 и 1 (или 0 и 1, в зависимости от выбранного начала последовательности).

## Сигнатура функции

```javascript
export function fibanacci(number)
```

### Параметры

- `number`: Порядковый номер (n) числа Фибоначчи в последовательности, которое функция должна вычислить.

## Принцип работы функции

Функция `fibanaсchi` использует рекурсивный подход для вычисления чисел Фибоначчи. Работа функции описывается следующими шагами:

1. Проверка базового случая: если `number` меньше или равно 2, то возвращается 1, так как первые два элемента последовательности Фибоначчи равны 1.
```javascript
if (number <= 2) {
    return 1;
}
```

2. Рекурсивный вызов: функция вызывает саму себя дважды с уменьшенными параметрами для вычисления предшествующих чисел последовательности и возвращает их сумму, получая тем самым число Фибоначчи для заданного `number`.
```javascript
return fibanaсchi(number - 1) + fibanaсchi(number - 2)
```

### Особенности реализации

- **Рекурсия**: Ключевой момент реализации — это рекурсивные вызовы функции для вычисления предшествующих
  чисел Фибоначчи. Рекурсия позволяет просто и элегантно выразить идею последовательности Фибоначчи, но при этом может быть неэффективной из-за повторных вычислений одних и тех же значений.

### Концепции, используемые в коде

- **Рекурсия**: Эта функция является классическим примером рекурсии, когда для получения результата функция вызывает сама себя.

- **Базовый случай**: Так как рекурсивные функции должны иметь условия остановки, `number <= 2` служит в качестве такого условия для функции `fibanaсchi`.

- **Алгоритмическая сложность**: Наивный рекурсивный подход имеет экспоненциальную сложность времени выполнения (O(2^n)), так как каждый вызов функции порождает два новых вызова, и это число увеличивается экспоненциально с увеличением значения `number`.

### Проблемы реализации и возможные улучшения

Данный рекурсивный подход без использования техник оптимизации, таких как мемоизация или динамическое программирование, не является эффективным для больших значений `number`, поскольку многие вычисления повторяются. Например, значение `fibanaсchi(5)` будет вычислено несколько раз в процессе вычисления `fibanaсchi(7)`.

**Мемоизация**: Это процесс сохранения результатов выполненных ранее вычислений для предотвращения повторных рекурсивных вызовов. Мемоизация уменьшит сложность времени выполнения до O(n), так как каждое
число Фибоначчи будет вычислено всего один раз. Вместе с тем, последующие вызовы функции для этих чисел будут просто возвращать уже вычисленные значения из кеша памяти.

Пример улучшения функции `fibanaсchi` с использованием мемоизации:

```javascript
function fibanacci(number, memo = {}) {
    if (memo[number]) {
        return memo[number];
    }
    if (number <= 2) {
        return 1;
    }
    memo[number] = fibanacci(number - 1, memo) + fibanacci(number - 2, memo);
    return memo[number];
}
```

Здесь `memo` — это объект (хэш-таблица), который хранит уже вычисленные значения чисел Фибоначчи. Когда функция `fibanacci` вызывается с новым значением, она сначала проверяет, существует ли это значение в кеше. Если да, функция возвращает значение из кеша, избегая тем самым повторных вычислений.

### Заключение

Реализация функции `fibanaсchi` демонстрирует, как могут быть использованы фундаментальные концепции рекурсии и базовых случаев в алгоритмах, однако она также показывает типичные проблемы производительности, связанные с рекурсией и повторными расчетами. Оптимизация с помощью мемоизации является эффективным решением для повышения производительности, и это широко применимая практика при работе с рекурсивными алгоритмами. В контексте данной функции мемоизация позволяет избежать значительной избыточности вычислений, что критически важно при
работе с большими числами. Это сокращает количество операций с экспоненциального роста до линейного, что делает решение практически применимым даже для высоких порядковых номеров чисел в последовательности Фибоначчи.

## Использование функции

Чтобы использовать функцию `fibanacci` c мемоизацией, достаточно вызвать её с желаемым порядковым номером числа в последовательности Фибоначчи:

```javascript
const nthFibonacciNumber = fibanacci(10); // Вызов функции для вычисления 10-го числа Фибоначчи
console.log(nthFibonacciNumber); // Выведет 55, так как 10-е число Фибоначчи — это 55
```

## Рекомендации и предостережения

1. Все числа в JavaScript представлены в формате с плавающей запятой двойной точности (64-битный формат IEEE 754), что означает, что очень большие значения последовательности Фибоначчи могут быть представлены неточно из-за ограничений точности.

2. При вычислении очень больших чисел Фибоначчи следует учитывать ограничения памяти, так как размер кеша `memo` будет расти линейно с увеличением `number`.

3. Рекурсивные вызовы могут привести к переполнению стека вызовов, особенно без оптимизации хвостовой рекурсии, которая не всегда доступна в JavaScript. Мемоизация решает эту проблему, поскольку уменьшает глубину рекурсивных вызовов за счет кеширования результатов.

## Заключительное слово
В заключение, оптимизированная реализация функции fibanaсchi с использованием мемоизации позволяет эффективно и практично получать значения из последовательности Фибоначчи для больших чисел, существенно уменьшая количество необходимых вычислений и ускоряя работу алгоритма. Однако всегда важно помнить о возможных ограничениях и нюансах при использовании рекурсии и мемоизации, особенно при работе с числами большой размерности и долговременном хранении данных. Умелое применение подходов для оптимизации, таких как мемоизация, может быть ключевым для создания эффективных и масштабируемых программных решений.