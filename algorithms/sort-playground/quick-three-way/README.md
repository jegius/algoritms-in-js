# Three-way QuickSort

Three-way QuickSort (3-Way Partitioning) - это улучшенная версия быстрой сортировки, которая обрабатывает одинаковые элементы более эффективно. Этот алгоритм разрабатывался одновременно с Дькстрой и Хоаром. Он разделяет массив на три части:

- Меньше опорного.
- Равные опорному.
- Больше опорного.

Такой подход помогает эффективно управлять последовательностями с большим количеством одинаковых ключей, исключая необходимость сравнивать эти элементы в дальнейшем.

## Плюсы

- Более быстрое выполнение алгоритма на массивах с множеством повторяющихся элементов.
- Алгоритм прерывает работу, если обнаруживается, что все элементы массива равны, сокращая время выполнения для таких случаев.

## Минусы

- Этот алгоритм сложнее в понимании и реализации по сравнению с обычной быстрой сортировкой.

## Реализация

Функция `threeWayQuickSort` вызывает вспомогательную функцию `sort` с аргументами: массив данных, начальным и конечным индексами.

Функция `sort`:

- Проверяет, меньше ли верхний индекс или равен нижнему индексу. Если это так, то возврат из функции.
- Задает указатели `leftPointer`, `next` и `rightPointer`, а также `midData` как опорный элемент.
- В цикле while, поочередно сравнивает каждый элемент с опорным. Если элемент меньше опорного, он перемещается влево, если больше - вправо. Если элемент равен опорному, он остается на месте.
- Вызывает `sort` рекурсивно дважды после окончания цикла while для обработки элементов меньше и больше опорного.

## Отличия от классической быстрой сортировки

Классическое быстрая сортировка, придуманная Хоаром, всегда использует двухчастное разделение (также известное как "Lomuto partition scheme"), которое неэффективно работает с массивами, содержащими много повторяющихся элементов.

Это достигается за счет того, что элементы, равные опорному, не обрабатываются заново в последующих вызовах функции сортировки. Таким образом, алгоритм может значительно сократить количество операций, необходимых для сортировки массивов, содержащих много повторяющихся элементов, приводя к увеличению производительности.

Главная разница с классической быстрой сортировкой заключается в этом расширенном методе разделения и в способности эффективно обрабатывать повторяющиеся элементы.

```javascript
/**
 * Функция сортировки с помощью алгоритма трехчастной быстрой сортировки.
 *
 * @param {Array} data - Массив элементов, который нужно отсортировать.
 * @returns {Array} Возвращает отсортированный массив.
 */
export function threeWayQuickSort(data) {
    // Запускаем алгоритм сортировки на подмассиве, начинающемся с первого элемента и заканчивающемся последним.
    sort(data, 0, data.length - 1);
    return data;
}

/**
 * Вспомогательная рекурсивная функция для выполнения сортировки.
 *
 * @param {Array} data - Массив, который нужно отсортировать.
 * @param {Number} lowIndex - Нижний индекс участка массива, который нужно отсортировать.
 * @param {Number} heightIndex - Верхний индекс участка массива, который нужно отсортировать.
 */
function sort(data, lowIndex, heightIndex) {
    // Если верхний индекс меньше или равен нижнему индексу, можем прекратить сортировку.
    if (heightIndex <= lowIndex) {
        return;
    }

    let leftPointer = lowIndex;
    let next = lowIndex + 1;
    let rightPointer = heightIndex;
    const midData = data[lowIndex];

    // Начинаем процесс разделения на три части.
    while (next <= rightPointer) {
        const compareResult = compare(data[next], midData);

        // Если текущий элемент меньше опорного, меняем местами текущий элемент и элемент, на который указывает leftPointer, после чего передвигаем указатели.
        if (compareResult < 0) {
            swap(data, leftPointer++, next++);
        } else if (compareResult > 0) {
            // Если текущий элемент больше опорного, меняем местами текущий элемент и элемент, на который указывает rightPointer, после чего передвигаем указатель rightPointer.
            swap(data, next, rightPointer--);
        } else {
            // Если текущий элемент равен опорному, просто передвигаем указатель next.
            next++;
        }
    }

    // Разделение закончено, теперь применяем это же рекурсивно для обоих разделений: элементов меньше и больше опорного.
    sort(data, lowIndex, leftPointer - 1);
    sort(data, rightPointer + 1, heightIndex);
}
```