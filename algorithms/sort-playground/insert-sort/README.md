# Сортировка вставками:

## Описание алгоритма

Сортировка вставками - это простой алгоритм сортировки, в котором каждый следующий неотсортированной элемент последовательно сравнивается с отсортированными элементами и помещается на свое соответствующее место.

## Преимущества и недостатки

**Преимущества**:
- Простота реализации.
- Эффективный для небольших наборов данных.
- Отлично работает с частично отсортированными массивами.

**Недостатки**:
- Не эффективны для больших наборов данных: в худшем случае время выполнения составляет O(n^2).
- Не стабильна: может изменить относительный порядок равных элементов.

## Имплементация

Функция `insertSort` принимает в качестве параметра массив `data`, который нужно отсортировать. Функция `insertSortBody` выполняет реальную работу, выполняя сортировку вставками.

Эта функция генерирует подмассивы для каждого индекса `counter`, начиная с `gap` и заканчивая размером массива `size`. Затем, для каждого подмассива, цикл выполняет сравнение элементов и, если нужно, меняет их местами с использованием функции `swap`.

# Документация функции

```javascript 
export function insertSort(data) {
    /**
     * Сортирует массив данных "data" сортировкой вставками.
     *
     * Параметры:
     * - data: Массив чисел для сортировки.
     *
     * Возвращает: 
     * - Отсортированный по возрастанию массив.
     */

    // Вычисляем размер массива
    let size = data.length;

    // Вызывает функцию, выполняющую сортировку вставками
    insertSortBody(data, size)

    // Возвращает упорядоченный массив
    return data;
}

export function insertSortBody(data, size, gap = 1) {
    /**
     * Вспомогательная функция для сортировки вставками.
     *
     * Параметры:
     * - data: Массив данных для сортировки.
     * - size: Размер массива data. 
     * - gap: Расстояние между сравниваемыми элементами, по умолчанию 1.
     * 
     * Возвращает: 
     * - Отсортированный по возрастанию массив.
     */

    // Внешний цикл перемещает границу отсортированной и неотсортированной части
    for (let counter = gap; counter < size; counter++) {

        /* Внутренний цикл сортирует отсортированные подмассивы, перемещая текущий элемент на правильное место */
        for (let insertIndex = counter; insertIndex >= gap && less(data[insertIndex], data[insertIndex - gap]); insertIndex -= gap) {
            swap(data, insertIndex, insertIndex - gap);
        }
    }

    // Возвращает отсортированный массив
    return data;
}
```