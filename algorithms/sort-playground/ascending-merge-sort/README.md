# Сортировка слиянием:

## Описание алгоритма

Сортировка слиянием - это алгоритм сортировки, который на основе принципа "Разделяй и властвуй" разбивает список на отдельные элементы, а затем сливает их в порядке упорядочивания.

Цель восходящей сортировки слиянием - сортировка, начиная с наименьших подмассивов и постепенно увеличивая их размер, пока весь массив не будет отсортирован.

В отличие от обычной версии алгоритма сортировки слиянием, в восходящей сортировке слиянием не используется рекурсия.

## Преимущества и недостатки

**Преимущества**:
- Эффективный для больших наборов данных: в среднем время выполнения алгоритма сортировки слиянием составляет O(n log n).
- Не зависит от исходного расположения данных.
- Он работает стабильно, что означает, что он сохраняет относительный порядок равных элементов в отсортированном массиве.

**Недостатки**:
- Использует дополнительное пространство, равное размеру исходного массива, для слияния подмассивов.
- Большее количество операций сравнения по сравнению с другими алгоритмами, например, QuickSort.
- Рекурсивная реализация может вызвать переполнение стека для больших наборов данных.

## Имплементация

Функция `ascendingMergeSort` принимает в качестве параметра массив `data`, который необходимо отсортировать.

Сначала она создает вспомогательный массив `result`, затем инициализирует переменную `sliceIndex` значением 1.

Внешний цикл `for` удваивает значение `sliceIndex` на каждой итерации начиная от 1, пока `sliceIndex` не превысит длину массива.

Внутренний цикл `for` проходит по массиву `data`, разбивая его на подмассивы размером `sliceIndex` и сливая их в отсортированном порядке.

Операция слияния выполняется с использованием внешней функции `merge()`.

# Документация функции

```javascript
export function ascendingMergeSort(data) {
    /**
     * Сортирует массив данных "data" восходящей сортировкой слиянием.
     *
     * Параметры:
     * - data: Массив чисел для сортировки.
     *
     * Возвращает: 
     * - Отсортированный по восходящему методу слияния массив.
     */

    // Инициализируем вспомогательные переменные
    const index = data.length;
    const result = new Array(index);

    // Установим диапазон для каждого разделения массива
    for (let sliceIndex = 1; sliceIndex < index; sliceIndex *= 2) {
        // Создаем подмассивы и производим слияние в отсортированном порядке
        for (let lowIndex = 0; lowIndex < index - sliceIndex; lowIndex += sliceIndex * 2) {
            // Вызываем функцию слияния для каждого подмассива 
            merge(data, lowIndex, lowIndex + sliceIndex - 1, Math.min(lowIndex + sliceIndex * 2 - 1, index - 1), result);
        }
    }
    // Возвращаем отсортированный массив
    return data;
}
```